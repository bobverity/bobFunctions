// This file was automatically generated by odin.
// Do not edit by hand as changes will be lost.
#include <R.h>
#include <Rmath.h>
#include <Rinternals.h>
#include <R_ext/Rdynload.h>
#include <stdbool.h>

// Collect together all the parameters and transient memory
// required to run the model in a struct.
typedef struct SIR_deterministic_odin_pars {
  int odin_use_dde;
  double beta;
  double r;
  double mu;
  double I_init;
  double R_init;
  double N;
  double initial_S;
  double initial_I;
  double initial_R;
} SIR_deterministic_odin_pars;
SIR_deterministic_odin_pars* SIR_deterministic_odin_get_pointer(SEXP SIR_deterministic_odin_ptr, int closed_error);
SEXP SIR_deterministic_odin_set_user(SIR_deterministic_odin_pars *SIR_deterministic_odin_p, SEXP user);
typedef struct SIS_deterministic_odin_pars {
  int odin_use_dde;
  double beta;
  double r;
  double I_init;
  double N;
  double initial_S;
  double initial_I;
} SIS_deterministic_odin_pars;
SIS_deterministic_odin_pars* SIS_deterministic_odin_get_pointer(SEXP SIS_deterministic_odin_ptr, int closed_error);
SEXP SIS_deterministic_odin_set_user(SIS_deterministic_odin_pars *SIS_deterministic_odin_p, SEXP user);
typedef struct SIS_deterministic_odin2_pars {
  int odin_use_dde;
  double beta;
  double r;
  double I_init;
  double N;
  double initial_S;
  double initial_I;
} SIS_deterministic_odin2_pars;
SIS_deterministic_odin2_pars* SIS_deterministic_odin2_get_pointer(SEXP SIS_deterministic_odin2_ptr, int closed_error);
SEXP SIS_deterministic_odin2_set_user(SIS_deterministic_odin2_pars *SIS_deterministic_odin2_p, SEXP user);
typedef struct SLIR_deterministic_odin_pars {
  int odin_use_dde;
  double initial_t;
  double initial_L;
  double beta;
  double dur_lag;
  double r;
  double I_init;
  double R_init;
  double N;
  double initial_S;
  double initial_I;
  double initial_R;
  int dim_delay_S_delay;
  int *delay_i_S_delay;
  double *delay_state_S_delay;
  int dim_delay_I_delay;
  int *delay_i_I_delay;
  double *delay_state_I_delay;
} SLIR_deterministic_odin_pars;
SLIR_deterministic_odin_pars* SLIR_deterministic_odin_get_pointer(SEXP SLIR_deterministic_odin_ptr, int closed_error);
SEXP SLIR_deterministic_odin_set_user(SLIR_deterministic_odin_pars *SLIR_deterministic_odin_p, SEXP user);

SEXP get_ds_pars();
double get_user_double(SEXP user, const char *name, double default_value);
SEXP get_list_element(SEXP list, const char *name);
void lagvalue_dde(double t, int *idx, size_t dim_idx, double *state);
void lagvalue_ds(double t, int *idx, int dim_idx, double *state);

// Create the pointer; this will establish the struct, allocate
// memory for things that are constant size, and initialize
// constant variables
static void SIR_deterministic_odin_finalize(SEXP SIR_deterministic_odin_ptr);
SEXP SIR_deterministic_odin_create(SEXP user, SEXP odin_use_dde) {
  SIR_deterministic_odin_pars *SIR_deterministic_odin_p = (SIR_deterministic_odin_pars*) Calloc(1, SIR_deterministic_odin_pars);
  SIR_deterministic_odin_p->beta = NA_REAL;
  SIR_deterministic_odin_p->r = NA_REAL;
  SIR_deterministic_odin_p->mu = NA_REAL;
  SIR_deterministic_odin_p->I_init = NA_REAL;
  SIR_deterministic_odin_p->R_init = NA_REAL;
  SIR_deterministic_odin_p->N = NA_REAL;
  SEXP SIR_deterministic_odin_ptr = PROTECT(R_MakeExternalPtr(SIR_deterministic_odin_p, R_NilValue, R_NilValue));
  R_RegisterCFinalizer(SIR_deterministic_odin_ptr, SIR_deterministic_odin_finalize);
  SIR_deterministic_odin_set_user(SIR_deterministic_odin_p, user);
  SIR_deterministic_odin_p->odin_use_dde = INTEGER(odin_use_dde)[0];
  UNPROTECT(1);
  return SIR_deterministic_odin_ptr;
}

// Set user-supplied parameter values.
SEXP SIR_deterministic_odin_set_user(SIR_deterministic_odin_pars *SIR_deterministic_odin_p, SEXP user) {
  SIR_deterministic_odin_p->beta = get_user_double(user, "beta", SIR_deterministic_odin_p->beta);
  SIR_deterministic_odin_p->r = get_user_double(user, "r", SIR_deterministic_odin_p->r);
  SIR_deterministic_odin_p->mu = get_user_double(user, "mu", SIR_deterministic_odin_p->mu);
  SIR_deterministic_odin_p->I_init = get_user_double(user, "I_init", SIR_deterministic_odin_p->I_init);
  SIR_deterministic_odin_p->R_init = get_user_double(user, "R_init", SIR_deterministic_odin_p->R_init);
  SIR_deterministic_odin_p->N = get_user_double(user, "N", SIR_deterministic_odin_p->N);
  return R_NilValue;
}
// Wrapper around this for use from R.
SEXP r_SIR_deterministic_odin_set_user(SEXP SIR_deterministic_odin_ptr, SEXP user) {
  SIR_deterministic_odin_pars *SIR_deterministic_odin_p = SIR_deterministic_odin_get_pointer(SIR_deterministic_odin_ptr, 1);
  SIR_deterministic_odin_set_user(SIR_deterministic_odin_p, user);
  return R_NilValue;
}

// Arrange to free all memory we have allocated
// This is called by R automatically when the pointer is
// garbage collected (i.e., when all objects holding the pointer
// go out of scope
void SIR_deterministic_odin_finalize(SEXP SIR_deterministic_odin_ptr) {
  SIR_deterministic_odin_pars *SIR_deterministic_odin_p = SIR_deterministic_odin_get_pointer(SIR_deterministic_odin_ptr, 0);
  if (SIR_deterministic_odin_ptr) {
    Free(SIR_deterministic_odin_p);
    R_ClearExternalPtr(SIR_deterministic_odin_ptr);
  }
}

SEXP SIR_deterministic_odin_initialise(SEXP SIR_deterministic_odin_ptr, SEXP t_ptr) {
  SIR_deterministic_odin_pars *SIR_deterministic_odin_p = SIR_deterministic_odin_get_pointer(SIR_deterministic_odin_ptr, 1);
  SIR_deterministic_odin_p->initial_S = SIR_deterministic_odin_p->N - SIR_deterministic_odin_p->I_init - SIR_deterministic_odin_p->R_init;
  SIR_deterministic_odin_p->initial_I = SIR_deterministic_odin_p->I_init;
  SIR_deterministic_odin_p->initial_R = SIR_deterministic_odin_p->R_init;
  SEXP state = PROTECT(allocVector(REALSXP, 3));
  REAL(state)[0] = SIR_deterministic_odin_p->initial_S;
  REAL(state)[1] = SIR_deterministic_odin_p->initial_I;
  REAL(state)[2] = SIR_deterministic_odin_p->initial_R;
  UNPROTECT(1);
  return state;
}

SEXP SIR_deterministic_odin_set_initial(SEXP SIR_deterministic_odin_ptr, SEXP t_ptr, SEXP state_ptr) {
  return R_NilValue;
}

void SIR_deterministic_odin_deriv(SIR_deterministic_odin_pars *SIR_deterministic_odin_p, double t, double *state, double *dstatedt, double *output) {
  double S = state[0];
  double I = state[1];
  double R = state[2];
  dstatedt[0] = -SIR_deterministic_odin_p->beta * S * I / SIR_deterministic_odin_p->N + SIR_deterministic_odin_p->mu * (S + I + R) - SIR_deterministic_odin_p->mu * S;
  dstatedt[1] = SIR_deterministic_odin_p->beta * S * I / SIR_deterministic_odin_p->N - SIR_deterministic_odin_p->r * I - SIR_deterministic_odin_p->mu * I;
  dstatedt[2] = SIR_deterministic_odin_p->r * I - SIR_deterministic_odin_p->mu * R;
}

// deSolve interface
// Global variable set on initmod, as per deSolve design
static SIR_deterministic_odin_pars *SIR_deterministic_odin_p;
void SIR_deterministic_odin_initmod_ds(void(* odeparms) (int *, double *)) {
  DL_FUNC get_deSolve_gparms = R_GetCCallable("deSolve", "get_deSolve_gparms");
  SIR_deterministic_odin_p = SIR_deterministic_odin_get_pointer(get_deSolve_gparms(), 1);
}
void SIR_deterministic_odin_deriv_ds(int *neq, double *t, double *state,
                                     double *dstatedt, double *output, int *np) {
  SIR_deterministic_odin_deriv(SIR_deterministic_odin_p, *t, state, dstatedt, output);
}

// dde interface
void SIR_deterministic_odin_deriv_dde(size_t n_eq, double t, double *state,
                                       double *dstatedt, void *SIR_deterministic_odin_p) {
  SIR_deterministic_odin_deriv((SIR_deterministic_odin_pars*)SIR_deterministic_odin_p, t, state, dstatedt, NULL);
}

SEXP SIR_deterministic_odin_deriv_r(SEXP SIR_deterministic_odin_ptr, SEXP t, SEXP state) {
  SEXP dstatedt = PROTECT(allocVector(REALSXP, LENGTH(state)));
  SIR_deterministic_odin_pars *SIR_deterministic_odin_p = SIR_deterministic_odin_get_pointer(SIR_deterministic_odin_ptr, 1);
  double *output = NULL;
  SIR_deterministic_odin_deriv(SIR_deterministic_odin_p, REAL(t)[0], REAL(state), REAL(dstatedt), output);
  UNPROTECT(1);
  return dstatedt;
}

// Translate all elements in the struct back to R
// This will mostly be useful for debugging.
SEXP SIR_deterministic_odin_contents(SEXP SIR_deterministic_odin_ptr) {
  SIR_deterministic_odin_pars *SIR_deterministic_odin_p = SIR_deterministic_odin_get_pointer(SIR_deterministic_odin_ptr, 1);
  SEXP state = PROTECT(allocVector(VECSXP, 10));
  SET_VECTOR_ELT(state, 0, ScalarInteger(SIR_deterministic_odin_p->odin_use_dde));
  SET_VECTOR_ELT(state, 1, ScalarReal(SIR_deterministic_odin_p->beta));
  SET_VECTOR_ELT(state, 2, ScalarReal(SIR_deterministic_odin_p->r));
  SET_VECTOR_ELT(state, 3, ScalarReal(SIR_deterministic_odin_p->mu));
  SET_VECTOR_ELT(state, 4, ScalarReal(SIR_deterministic_odin_p->I_init));
  SET_VECTOR_ELT(state, 5, ScalarReal(SIR_deterministic_odin_p->R_init));
  SET_VECTOR_ELT(state, 6, ScalarReal(SIR_deterministic_odin_p->N));
  SET_VECTOR_ELT(state, 7, ScalarReal(SIR_deterministic_odin_p->initial_S));
  SET_VECTOR_ELT(state, 8, ScalarReal(SIR_deterministic_odin_p->initial_I));
  SET_VECTOR_ELT(state, 9, ScalarReal(SIR_deterministic_odin_p->initial_R));
  SEXP state_names = PROTECT(allocVector(STRSXP, 10));
  SET_STRING_ELT(state_names, 0, mkChar("odin_use_dde"));
  SET_STRING_ELT(state_names, 1, mkChar("beta"));
  SET_STRING_ELT(state_names, 2, mkChar("r"));
  SET_STRING_ELT(state_names, 3, mkChar("mu"));
  SET_STRING_ELT(state_names, 4, mkChar("I_init"));
  SET_STRING_ELT(state_names, 5, mkChar("R_init"));
  SET_STRING_ELT(state_names, 6, mkChar("N"));
  SET_STRING_ELT(state_names, 7, mkChar("initial_S"));
  SET_STRING_ELT(state_names, 8, mkChar("initial_I"));
  SET_STRING_ELT(state_names, 9, mkChar("initial_R"));
  setAttrib(state, R_NamesSymbol, state_names);
  UNPROTECT(2);
  return state;
}

// Report back to R information on variable ordering
// The reported information includes position and length of each
// variable, from which offset, etc, can be worked out.
SEXP SIR_deterministic_odin_variable_order(SEXP SIR_deterministic_odin_ptr) {
  SEXP state_len = PROTECT(allocVector(VECSXP, 3));
  SEXP state_names = PROTECT(allocVector(STRSXP, 3));
  SET_VECTOR_ELT(state_len, 0, R_NilValue);
  SET_STRING_ELT(state_names, 0, mkChar("S"));
  SET_VECTOR_ELT(state_len, 1, R_NilValue);
  SET_STRING_ELT(state_names, 1, mkChar("I"));
  SET_VECTOR_ELT(state_len, 2, R_NilValue);
  SET_STRING_ELT(state_names, 2, mkChar("R"));
  setAttrib(state_len, R_NamesSymbol, state_names);
  UNPROTECT(2);
  return state_len;
}

SIR_deterministic_odin_pars* SIR_deterministic_odin_get_pointer(SEXP SIR_deterministic_odin_ptr, int closed_error) {
  SIR_deterministic_odin_pars *SIR_deterministic_odin_p = NULL;
  if (TYPEOF(SIR_deterministic_odin_ptr) != EXTPTRSXP) {
    Rf_error("Expected an external pointer");
  }
  SIR_deterministic_odin_p = (SIR_deterministic_odin_pars*) R_ExternalPtrAddr(SIR_deterministic_odin_ptr);
  if (!SIR_deterministic_odin_p && closed_error) {
    Rf_error("Pointer has been invalidated");
  }
  return SIR_deterministic_odin_p;
}
// Create the pointer; this will establish the struct, allocate
// memory for things that are constant size, and initialize
// constant variables
static void SIS_deterministic_odin_finalize(SEXP SIS_deterministic_odin_ptr);
SEXP SIS_deterministic_odin_create(SEXP user, SEXP odin_use_dde) {
  SIS_deterministic_odin_pars *SIS_deterministic_odin_p = (SIS_deterministic_odin_pars*) Calloc(1, SIS_deterministic_odin_pars);
  SIS_deterministic_odin_p->beta = NA_REAL;
  SIS_deterministic_odin_p->r = NA_REAL;
  SIS_deterministic_odin_p->I_init = NA_REAL;
  SIS_deterministic_odin_p->N = NA_REAL;
  SEXP SIS_deterministic_odin_ptr = PROTECT(R_MakeExternalPtr(SIS_deterministic_odin_p, R_NilValue, R_NilValue));
  R_RegisterCFinalizer(SIS_deterministic_odin_ptr, SIS_deterministic_odin_finalize);
  SIS_deterministic_odin_set_user(SIS_deterministic_odin_p, user);
  SIS_deterministic_odin_p->odin_use_dde = INTEGER(odin_use_dde)[0];
  UNPROTECT(1);
  return SIS_deterministic_odin_ptr;
}

// Set user-supplied parameter values.
SEXP SIS_deterministic_odin_set_user(SIS_deterministic_odin_pars *SIS_deterministic_odin_p, SEXP user) {
  SIS_deterministic_odin_p->beta = get_user_double(user, "beta", SIS_deterministic_odin_p->beta);
  SIS_deterministic_odin_p->r = get_user_double(user, "r", SIS_deterministic_odin_p->r);
  SIS_deterministic_odin_p->I_init = get_user_double(user, "I_init", SIS_deterministic_odin_p->I_init);
  SIS_deterministic_odin_p->N = get_user_double(user, "N", SIS_deterministic_odin_p->N);
  return R_NilValue;
}
// Wrapper around this for use from R.
SEXP r_SIS_deterministic_odin_set_user(SEXP SIS_deterministic_odin_ptr, SEXP user) {
  SIS_deterministic_odin_pars *SIS_deterministic_odin_p = SIS_deterministic_odin_get_pointer(SIS_deterministic_odin_ptr, 1);
  SIS_deterministic_odin_set_user(SIS_deterministic_odin_p, user);
  return R_NilValue;
}

// Arrange to free all memory we have allocated
// This is called by R automatically when the pointer is
// garbage collected (i.e., when all objects holding the pointer
// go out of scope
void SIS_deterministic_odin_finalize(SEXP SIS_deterministic_odin_ptr) {
  SIS_deterministic_odin_pars *SIS_deterministic_odin_p = SIS_deterministic_odin_get_pointer(SIS_deterministic_odin_ptr, 0);
  if (SIS_deterministic_odin_ptr) {
    Free(SIS_deterministic_odin_p);
    R_ClearExternalPtr(SIS_deterministic_odin_ptr);
  }
}

SEXP SIS_deterministic_odin_initialise(SEXP SIS_deterministic_odin_ptr, SEXP t_ptr) {
  SIS_deterministic_odin_pars *SIS_deterministic_odin_p = SIS_deterministic_odin_get_pointer(SIS_deterministic_odin_ptr, 1);
  SIS_deterministic_odin_p->initial_S = SIS_deterministic_odin_p->N - SIS_deterministic_odin_p->I_init;
  SIS_deterministic_odin_p->initial_I = SIS_deterministic_odin_p->I_init;
  SEXP state = PROTECT(allocVector(REALSXP, 2));
  REAL(state)[0] = SIS_deterministic_odin_p->initial_S;
  REAL(state)[1] = SIS_deterministic_odin_p->initial_I;
  UNPROTECT(1);
  return state;
}

SEXP SIS_deterministic_odin_set_initial(SEXP SIS_deterministic_odin_ptr, SEXP t_ptr, SEXP state_ptr) {
  return R_NilValue;
}

void SIS_deterministic_odin_deriv(SIS_deterministic_odin_pars *SIS_deterministic_odin_p, double t, double *state, double *dstatedt, double *output) {
  double S = state[0];
  double I = state[1];
  dstatedt[0] = -SIS_deterministic_odin_p->beta * S * I / SIS_deterministic_odin_p->N + SIS_deterministic_odin_p->r * I;
  dstatedt[1] = SIS_deterministic_odin_p->beta * S * I / SIS_deterministic_odin_p->N - SIS_deterministic_odin_p->r * I;
}

// deSolve interface
// Global variable set on initmod, as per deSolve design
static SIS_deterministic_odin_pars *SIS_deterministic_odin_p;
void SIS_deterministic_odin_initmod_ds(void(* odeparms) (int *, double *)) {
  DL_FUNC get_deSolve_gparms = R_GetCCallable("deSolve", "get_deSolve_gparms");
  SIS_deterministic_odin_p = SIS_deterministic_odin_get_pointer(get_deSolve_gparms(), 1);
}
void SIS_deterministic_odin_deriv_ds(int *neq, double *t, double *state,
                                     double *dstatedt, double *output, int *np) {
  SIS_deterministic_odin_deriv(SIS_deterministic_odin_p, *t, state, dstatedt, output);
}

// dde interface
void SIS_deterministic_odin_deriv_dde(size_t n_eq, double t, double *state,
                                       double *dstatedt, void *SIS_deterministic_odin_p) {
  SIS_deterministic_odin_deriv((SIS_deterministic_odin_pars*)SIS_deterministic_odin_p, t, state, dstatedt, NULL);
}

SEXP SIS_deterministic_odin_deriv_r(SEXP SIS_deterministic_odin_ptr, SEXP t, SEXP state) {
  SEXP dstatedt = PROTECT(allocVector(REALSXP, LENGTH(state)));
  SIS_deterministic_odin_pars *SIS_deterministic_odin_p = SIS_deterministic_odin_get_pointer(SIS_deterministic_odin_ptr, 1);
  double *output = NULL;
  SIS_deterministic_odin_deriv(SIS_deterministic_odin_p, REAL(t)[0], REAL(state), REAL(dstatedt), output);
  UNPROTECT(1);
  return dstatedt;
}

// Translate all elements in the struct back to R
// This will mostly be useful for debugging.
SEXP SIS_deterministic_odin_contents(SEXP SIS_deterministic_odin_ptr) {
  SIS_deterministic_odin_pars *SIS_deterministic_odin_p = SIS_deterministic_odin_get_pointer(SIS_deterministic_odin_ptr, 1);
  SEXP state = PROTECT(allocVector(VECSXP, 7));
  SET_VECTOR_ELT(state, 0, ScalarInteger(SIS_deterministic_odin_p->odin_use_dde));
  SET_VECTOR_ELT(state, 1, ScalarReal(SIS_deterministic_odin_p->beta));
  SET_VECTOR_ELT(state, 2, ScalarReal(SIS_deterministic_odin_p->r));
  SET_VECTOR_ELT(state, 3, ScalarReal(SIS_deterministic_odin_p->I_init));
  SET_VECTOR_ELT(state, 4, ScalarReal(SIS_deterministic_odin_p->N));
  SET_VECTOR_ELT(state, 5, ScalarReal(SIS_deterministic_odin_p->initial_S));
  SET_VECTOR_ELT(state, 6, ScalarReal(SIS_deterministic_odin_p->initial_I));
  SEXP state_names = PROTECT(allocVector(STRSXP, 7));
  SET_STRING_ELT(state_names, 0, mkChar("odin_use_dde"));
  SET_STRING_ELT(state_names, 1, mkChar("beta"));
  SET_STRING_ELT(state_names, 2, mkChar("r"));
  SET_STRING_ELT(state_names, 3, mkChar("I_init"));
  SET_STRING_ELT(state_names, 4, mkChar("N"));
  SET_STRING_ELT(state_names, 5, mkChar("initial_S"));
  SET_STRING_ELT(state_names, 6, mkChar("initial_I"));
  setAttrib(state, R_NamesSymbol, state_names);
  UNPROTECT(2);
  return state;
}

// Report back to R information on variable ordering
// The reported information includes position and length of each
// variable, from which offset, etc, can be worked out.
SEXP SIS_deterministic_odin_variable_order(SEXP SIS_deterministic_odin_ptr) {
  SEXP state_len = PROTECT(allocVector(VECSXP, 2));
  SEXP state_names = PROTECT(allocVector(STRSXP, 2));
  SET_VECTOR_ELT(state_len, 0, R_NilValue);
  SET_STRING_ELT(state_names, 0, mkChar("S"));
  SET_VECTOR_ELT(state_len, 1, R_NilValue);
  SET_STRING_ELT(state_names, 1, mkChar("I"));
  setAttrib(state_len, R_NamesSymbol, state_names);
  UNPROTECT(2);
  return state_len;
}

SIS_deterministic_odin_pars* SIS_deterministic_odin_get_pointer(SEXP SIS_deterministic_odin_ptr, int closed_error) {
  SIS_deterministic_odin_pars *SIS_deterministic_odin_p = NULL;
  if (TYPEOF(SIS_deterministic_odin_ptr) != EXTPTRSXP) {
    Rf_error("Expected an external pointer");
  }
  SIS_deterministic_odin_p = (SIS_deterministic_odin_pars*) R_ExternalPtrAddr(SIS_deterministic_odin_ptr);
  if (!SIS_deterministic_odin_p && closed_error) {
    Rf_error("Pointer has been invalidated");
  }
  return SIS_deterministic_odin_p;
}
// Create the pointer; this will establish the struct, allocate
// memory for things that are constant size, and initialize
// constant variables
static void SIS_deterministic_odin2_finalize(SEXP SIS_deterministic_odin2_ptr);
SEXP SIS_deterministic_odin2_create(SEXP user, SEXP odin_use_dde) {
  SIS_deterministic_odin2_pars *SIS_deterministic_odin2_p = (SIS_deterministic_odin2_pars*) Calloc(1, SIS_deterministic_odin2_pars);
  SIS_deterministic_odin2_p->beta = NA_REAL;
  SIS_deterministic_odin2_p->r = NA_REAL;
  SIS_deterministic_odin2_p->I_init = NA_REAL;
  SIS_deterministic_odin2_p->N = NA_REAL;
  SEXP SIS_deterministic_odin2_ptr = PROTECT(R_MakeExternalPtr(SIS_deterministic_odin2_p, R_NilValue, R_NilValue));
  R_RegisterCFinalizer(SIS_deterministic_odin2_ptr, SIS_deterministic_odin2_finalize);
  SIS_deterministic_odin2_set_user(SIS_deterministic_odin2_p, user);
  SIS_deterministic_odin2_p->odin_use_dde = INTEGER(odin_use_dde)[0];
  UNPROTECT(1);
  return SIS_deterministic_odin2_ptr;
}

// Set user-supplied parameter values.
SEXP SIS_deterministic_odin2_set_user(SIS_deterministic_odin2_pars *SIS_deterministic_odin2_p, SEXP user) {
  SIS_deterministic_odin2_p->beta = get_user_double(user, "beta", SIS_deterministic_odin2_p->beta);
  SIS_deterministic_odin2_p->r = get_user_double(user, "r", SIS_deterministic_odin2_p->r);
  SIS_deterministic_odin2_p->I_init = get_user_double(user, "I_init", SIS_deterministic_odin2_p->I_init);
  SIS_deterministic_odin2_p->N = get_user_double(user, "N", SIS_deterministic_odin2_p->N);
  return R_NilValue;
}
// Wrapper around this for use from R.
SEXP r_SIS_deterministic_odin2_set_user(SEXP SIS_deterministic_odin2_ptr, SEXP user) {
  SIS_deterministic_odin2_pars *SIS_deterministic_odin2_p = SIS_deterministic_odin2_get_pointer(SIS_deterministic_odin2_ptr, 1);
  SIS_deterministic_odin2_set_user(SIS_deterministic_odin2_p, user);
  return R_NilValue;
}

// Arrange to free all memory we have allocated
// This is called by R automatically when the pointer is
// garbage collected (i.e., when all objects holding the pointer
// go out of scope
void SIS_deterministic_odin2_finalize(SEXP SIS_deterministic_odin2_ptr) {
  SIS_deterministic_odin2_pars *SIS_deterministic_odin2_p = SIS_deterministic_odin2_get_pointer(SIS_deterministic_odin2_ptr, 0);
  if (SIS_deterministic_odin2_ptr) {
    Free(SIS_deterministic_odin2_p);
    R_ClearExternalPtr(SIS_deterministic_odin2_ptr);
  }
}

SEXP SIS_deterministic_odin2_initialise(SEXP SIS_deterministic_odin2_ptr, SEXP t_ptr) {
  SIS_deterministic_odin2_pars *SIS_deterministic_odin2_p = SIS_deterministic_odin2_get_pointer(SIS_deterministic_odin2_ptr, 1);
  SIS_deterministic_odin2_p->initial_S = SIS_deterministic_odin2_p->N - SIS_deterministic_odin2_p->I_init;
  SIS_deterministic_odin2_p->initial_I = SIS_deterministic_odin2_p->I_init;
  SEXP state = PROTECT(allocVector(REALSXP, 2));
  REAL(state)[0] = SIS_deterministic_odin2_p->initial_S;
  REAL(state)[1] = SIS_deterministic_odin2_p->initial_I;
  UNPROTECT(1);
  return state;
}

SEXP SIS_deterministic_odin2_set_initial(SEXP SIS_deterministic_odin2_ptr, SEXP t_ptr, SEXP state_ptr) {
  return R_NilValue;
}

void SIS_deterministic_odin2_deriv(SIS_deterministic_odin2_pars *SIS_deterministic_odin2_p, double t, double *state, double *dstatedt, double *output) {
  double S = state[0];
  double I = state[1];
  dstatedt[0] = -SIS_deterministic_odin2_p->beta * S * I / SIS_deterministic_odin2_p->N + SIS_deterministic_odin2_p->r * I;
  dstatedt[1] = SIS_deterministic_odin2_p->beta * S * I / SIS_deterministic_odin2_p->N - SIS_deterministic_odin2_p->r * I;
}

// deSolve interface
// Global variable set on initmod, as per deSolve design
static SIS_deterministic_odin2_pars *SIS_deterministic_odin2_p;
void SIS_deterministic_odin2_initmod_ds(void(* odeparms) (int *, double *)) {
  DL_FUNC get_deSolve_gparms = R_GetCCallable("deSolve", "get_deSolve_gparms");
  SIS_deterministic_odin2_p = SIS_deterministic_odin2_get_pointer(get_deSolve_gparms(), 1);
}
void SIS_deterministic_odin2_deriv_ds(int *neq, double *t, double *state,
                                      double *dstatedt, double *output, int *np) {
  SIS_deterministic_odin2_deriv(SIS_deterministic_odin2_p, *t, state, dstatedt, output);
}

// dde interface
void SIS_deterministic_odin2_deriv_dde(size_t n_eq, double t, double *state,
                                        double *dstatedt, void *SIS_deterministic_odin2_p) {
  SIS_deterministic_odin2_deriv((SIS_deterministic_odin2_pars*)SIS_deterministic_odin2_p, t, state, dstatedt, NULL);
}

SEXP SIS_deterministic_odin2_deriv_r(SEXP SIS_deterministic_odin2_ptr, SEXP t, SEXP state) {
  SEXP dstatedt = PROTECT(allocVector(REALSXP, LENGTH(state)));
  SIS_deterministic_odin2_pars *SIS_deterministic_odin2_p = SIS_deterministic_odin2_get_pointer(SIS_deterministic_odin2_ptr, 1);
  double *output = NULL;
  SIS_deterministic_odin2_deriv(SIS_deterministic_odin2_p, REAL(t)[0], REAL(state), REAL(dstatedt), output);
  UNPROTECT(1);
  return dstatedt;
}

// Translate all elements in the struct back to R
// This will mostly be useful for debugging.
SEXP SIS_deterministic_odin2_contents(SEXP SIS_deterministic_odin2_ptr) {
  SIS_deterministic_odin2_pars *SIS_deterministic_odin2_p = SIS_deterministic_odin2_get_pointer(SIS_deterministic_odin2_ptr, 1);
  SEXP state = PROTECT(allocVector(VECSXP, 7));
  SET_VECTOR_ELT(state, 0, ScalarInteger(SIS_deterministic_odin2_p->odin_use_dde));
  SET_VECTOR_ELT(state, 1, ScalarReal(SIS_deterministic_odin2_p->beta));
  SET_VECTOR_ELT(state, 2, ScalarReal(SIS_deterministic_odin2_p->r));
  SET_VECTOR_ELT(state, 3, ScalarReal(SIS_deterministic_odin2_p->I_init));
  SET_VECTOR_ELT(state, 4, ScalarReal(SIS_deterministic_odin2_p->N));
  SET_VECTOR_ELT(state, 5, ScalarReal(SIS_deterministic_odin2_p->initial_S));
  SET_VECTOR_ELT(state, 6, ScalarReal(SIS_deterministic_odin2_p->initial_I));
  SEXP state_names = PROTECT(allocVector(STRSXP, 7));
  SET_STRING_ELT(state_names, 0, mkChar("odin_use_dde"));
  SET_STRING_ELT(state_names, 1, mkChar("beta"));
  SET_STRING_ELT(state_names, 2, mkChar("r"));
  SET_STRING_ELT(state_names, 3, mkChar("I_init"));
  SET_STRING_ELT(state_names, 4, mkChar("N"));
  SET_STRING_ELT(state_names, 5, mkChar("initial_S"));
  SET_STRING_ELT(state_names, 6, mkChar("initial_I"));
  setAttrib(state, R_NamesSymbol, state_names);
  UNPROTECT(2);
  return state;
}

// Report back to R information on variable ordering
// The reported information includes position and length of each
// variable, from which offset, etc, can be worked out.
SEXP SIS_deterministic_odin2_variable_order(SEXP SIS_deterministic_odin2_ptr) {
  SEXP state_len = PROTECT(allocVector(VECSXP, 2));
  SEXP state_names = PROTECT(allocVector(STRSXP, 2));
  SET_VECTOR_ELT(state_len, 0, R_NilValue);
  SET_STRING_ELT(state_names, 0, mkChar("S"));
  SET_VECTOR_ELT(state_len, 1, R_NilValue);
  SET_STRING_ELT(state_names, 1, mkChar("I"));
  setAttrib(state_len, R_NamesSymbol, state_names);
  UNPROTECT(2);
  return state_len;
}

SIS_deterministic_odin2_pars* SIS_deterministic_odin2_get_pointer(SEXP SIS_deterministic_odin2_ptr, int closed_error) {
  SIS_deterministic_odin2_pars *SIS_deterministic_odin2_p = NULL;
  if (TYPEOF(SIS_deterministic_odin2_ptr) != EXTPTRSXP) {
    Rf_error("Expected an external pointer");
  }
  SIS_deterministic_odin2_p = (SIS_deterministic_odin2_pars*) R_ExternalPtrAddr(SIS_deterministic_odin2_ptr);
  if (!SIS_deterministic_odin2_p && closed_error) {
    Rf_error("Pointer has been invalidated");
  }
  return SIS_deterministic_odin2_p;
}
// Create the pointer; this will establish the struct, allocate
// memory for things that are constant size, and initialize
// constant variables
static void SLIR_deterministic_odin_finalize(SEXP SLIR_deterministic_odin_ptr);
SEXP SLIR_deterministic_odin_create(SEXP user, SEXP odin_use_dde) {
  SLIR_deterministic_odin_pars *SLIR_deterministic_odin_p = (SLIR_deterministic_odin_pars*) Calloc(1, SLIR_deterministic_odin_pars);
  SLIR_deterministic_odin_p->beta = NA_REAL;
  SLIR_deterministic_odin_p->dur_lag = NA_REAL;
  SLIR_deterministic_odin_p->r = NA_REAL;
  SLIR_deterministic_odin_p->I_init = NA_REAL;
  SLIR_deterministic_odin_p->R_init = NA_REAL;
  SLIR_deterministic_odin_p->N = NA_REAL;
  SLIR_deterministic_odin_p->dim_delay_S_delay = 1;
  SLIR_deterministic_odin_p->delay_i_S_delay = (int*) Calloc(SLIR_deterministic_odin_p->dim_delay_S_delay, int);
  SLIR_deterministic_odin_p->delay_state_S_delay = (double*) Calloc(SLIR_deterministic_odin_p->dim_delay_S_delay, double);
  {
    // delay block for S_delay
    int j = 0;
    SLIR_deterministic_odin_p->delay_i_S_delay[j++] = 0;
  }
  SLIR_deterministic_odin_p->dim_delay_I_delay = 1;
  SLIR_deterministic_odin_p->delay_i_I_delay = (int*) Calloc(SLIR_deterministic_odin_p->dim_delay_I_delay, int);
  SLIR_deterministic_odin_p->delay_state_I_delay = (double*) Calloc(SLIR_deterministic_odin_p->dim_delay_I_delay, double);
  {
    // delay block for I_delay
    int j = 0;
    SLIR_deterministic_odin_p->delay_i_I_delay[j++] = 2;
  }
  SEXP SLIR_deterministic_odin_ptr = PROTECT(R_MakeExternalPtr(SLIR_deterministic_odin_p, R_NilValue, R_NilValue));
  R_RegisterCFinalizer(SLIR_deterministic_odin_ptr, SLIR_deterministic_odin_finalize);
  SLIR_deterministic_odin_set_user(SLIR_deterministic_odin_p, user);
  SLIR_deterministic_odin_p->odin_use_dde = INTEGER(odin_use_dde)[0];
  UNPROTECT(1);
  return SLIR_deterministic_odin_ptr;
}

// Set user-supplied parameter values.
SEXP SLIR_deterministic_odin_set_user(SLIR_deterministic_odin_pars *SLIR_deterministic_odin_p, SEXP user) {
  SLIR_deterministic_odin_p->beta = get_user_double(user, "beta", SLIR_deterministic_odin_p->beta);
  SLIR_deterministic_odin_p->dur_lag = get_user_double(user, "dur_lag", SLIR_deterministic_odin_p->dur_lag);
  SLIR_deterministic_odin_p->r = get_user_double(user, "r", SLIR_deterministic_odin_p->r);
  SLIR_deterministic_odin_p->I_init = get_user_double(user, "I_init", SLIR_deterministic_odin_p->I_init);
  SLIR_deterministic_odin_p->R_init = get_user_double(user, "R_init", SLIR_deterministic_odin_p->R_init);
  SLIR_deterministic_odin_p->N = get_user_double(user, "N", SLIR_deterministic_odin_p->N);
  return R_NilValue;
}
// Wrapper around this for use from R.
SEXP r_SLIR_deterministic_odin_set_user(SEXP SLIR_deterministic_odin_ptr, SEXP user) {
  SLIR_deterministic_odin_pars *SLIR_deterministic_odin_p = SLIR_deterministic_odin_get_pointer(SLIR_deterministic_odin_ptr, 1);
  SLIR_deterministic_odin_set_user(SLIR_deterministic_odin_p, user);
  return R_NilValue;
}

// Arrange to free all memory we have allocated
// This is called by R automatically when the pointer is
// garbage collected (i.e., when all objects holding the pointer
// go out of scope
void SLIR_deterministic_odin_finalize(SEXP SLIR_deterministic_odin_ptr) {
  SLIR_deterministic_odin_pars *SLIR_deterministic_odin_p = SLIR_deterministic_odin_get_pointer(SLIR_deterministic_odin_ptr, 0);
  if (SLIR_deterministic_odin_ptr) {
    Free(SLIR_deterministic_odin_p->delay_i_S_delay);
    Free(SLIR_deterministic_odin_p->delay_state_S_delay);
    Free(SLIR_deterministic_odin_p->delay_i_I_delay);
    Free(SLIR_deterministic_odin_p->delay_state_I_delay);
    Free(SLIR_deterministic_odin_p);
    R_ClearExternalPtr(SLIR_deterministic_odin_ptr);
  }
}

SEXP SLIR_deterministic_odin_initialise(SEXP SLIR_deterministic_odin_ptr, SEXP t_ptr) {
  SLIR_deterministic_odin_pars *SLIR_deterministic_odin_p = SLIR_deterministic_odin_get_pointer(SLIR_deterministic_odin_ptr, 1);
  const double t = REAL(t_ptr)[0];
  SLIR_deterministic_odin_p->initial_t = t;
  SLIR_deterministic_odin_p->initial_L = 0;
  SLIR_deterministic_odin_p->initial_S = SLIR_deterministic_odin_p->N - SLIR_deterministic_odin_p->I_init - SLIR_deterministic_odin_p->R_init;
  SLIR_deterministic_odin_p->initial_I = SLIR_deterministic_odin_p->I_init;
  SLIR_deterministic_odin_p->initial_R = SLIR_deterministic_odin_p->R_init;
  SEXP state = PROTECT(allocVector(REALSXP, 4));
  REAL(state)[0] = SLIR_deterministic_odin_p->initial_S;
  REAL(state)[1] = SLIR_deterministic_odin_p->initial_L;
  REAL(state)[2] = SLIR_deterministic_odin_p->initial_I;
  REAL(state)[3] = SLIR_deterministic_odin_p->initial_R;
  UNPROTECT(1);
  return state;
}

SEXP SLIR_deterministic_odin_set_initial(SEXP SLIR_deterministic_odin_ptr, SEXP t_ptr, SEXP state_ptr) {
  SLIR_deterministic_odin_pars *SLIR_deterministic_odin_p = SLIR_deterministic_odin_get_pointer(SLIR_deterministic_odin_ptr, 1);
  if (length(SLIR_deterministic_odin_ptr) != 4) {
    Rf_error("Incorrect length initial conditions");
  }
  double * state = REAL(state_ptr);
  const double t = REAL(t_ptr)[0];
  SLIR_deterministic_odin_p->initial_t = t;
  SLIR_deterministic_odin_p->initial_S = state[0];
  SLIR_deterministic_odin_p->initial_L = state[1];
  SLIR_deterministic_odin_p->initial_I = state[2];
  SLIR_deterministic_odin_p->initial_R = state[3];
  return R_NilValue;
}

void SLIR_deterministic_odin_deriv(SLIR_deterministic_odin_pars *SLIR_deterministic_odin_p, double t, double *state, double *dstatedt, double *output) {
  double S = state[0];
  double I = state[2];
  double S_delay;
  {
    // delay block for S_delay
    const double odin_true_t = t;
    const double t = odin_true_t - SLIR_deterministic_odin_p->dur_lag;
    if (t <= SLIR_deterministic_odin_p->initial_t) {
      S_delay = 0;
    } else {
      double S;
      if (SLIR_deterministic_odin_p->odin_use_dde) {
        lagvalue_dde(t, SLIR_deterministic_odin_p->delay_i_S_delay, SLIR_deterministic_odin_p->dim_delay_S_delay, SLIR_deterministic_odin_p->delay_state_S_delay);
      } else {
        lagvalue_ds(t, SLIR_deterministic_odin_p->delay_i_S_delay, SLIR_deterministic_odin_p->dim_delay_S_delay, SLIR_deterministic_odin_p->delay_state_S_delay);
      }
      S = SLIR_deterministic_odin_p->delay_state_S_delay[0];
      S_delay = S;
    }
  }
  double I_delay;
  {
    // delay block for I_delay
    const double odin_true_t = t;
    const double t = odin_true_t - SLIR_deterministic_odin_p->dur_lag;
    if (t <= SLIR_deterministic_odin_p->initial_t) {
      I_delay = 0;
    } else {
      double I;
      if (SLIR_deterministic_odin_p->odin_use_dde) {
        lagvalue_dde(t, SLIR_deterministic_odin_p->delay_i_I_delay, SLIR_deterministic_odin_p->dim_delay_I_delay, SLIR_deterministic_odin_p->delay_state_I_delay);
      } else {
        lagvalue_ds(t, SLIR_deterministic_odin_p->delay_i_I_delay, SLIR_deterministic_odin_p->dim_delay_I_delay, SLIR_deterministic_odin_p->delay_state_I_delay);
      }
      I = SLIR_deterministic_odin_p->delay_state_I_delay[0];
      I_delay = I;
    }
  }
  dstatedt[0] = -SLIR_deterministic_odin_p->beta * S * I / SLIR_deterministic_odin_p->N;
  dstatedt[1] = SLIR_deterministic_odin_p->beta * S * I / SLIR_deterministic_odin_p->N - SLIR_deterministic_odin_p->beta * S_delay * I_delay / SLIR_deterministic_odin_p->N;
  dstatedt[2] = SLIR_deterministic_odin_p->beta * S_delay * I_delay / SLIR_deterministic_odin_p->N - SLIR_deterministic_odin_p->r * I;
  dstatedt[3] = SLIR_deterministic_odin_p->r * I;
}

// deSolve interface
// Global variable set on initmod, as per deSolve design
static SLIR_deterministic_odin_pars *SLIR_deterministic_odin_p;
void SLIR_deterministic_odin_initmod_ds(void(* odeparms) (int *, double *)) {
  DL_FUNC get_deSolve_gparms = R_GetCCallable("deSolve", "get_deSolve_gparms");
  SLIR_deterministic_odin_p = SLIR_deterministic_odin_get_pointer(get_deSolve_gparms(), 1);
}
void SLIR_deterministic_odin_deriv_ds(int *neq, double *t, double *state,
                                      double *dstatedt, double *output, int *np) {
  SLIR_deterministic_odin_deriv(SLIR_deterministic_odin_p, *t, state, dstatedt, output);
}

// dde interface
void SLIR_deterministic_odin_deriv_dde(size_t n_eq, double t, double *state,
                                        double *dstatedt, void *SLIR_deterministic_odin_p) {
  SLIR_deterministic_odin_deriv((SLIR_deterministic_odin_pars*)SLIR_deterministic_odin_p, t, state, dstatedt, NULL);
}

SEXP SLIR_deterministic_odin_deriv_r(SEXP SLIR_deterministic_odin_ptr, SEXP t, SEXP state) {
  SEXP dstatedt = PROTECT(allocVector(REALSXP, LENGTH(state)));
  SLIR_deterministic_odin_pars *SLIR_deterministic_odin_p = SLIR_deterministic_odin_get_pointer(SLIR_deterministic_odin_ptr, 1);
  double *output = NULL;
  SLIR_deterministic_odin_deriv(SLIR_deterministic_odin_p, REAL(t)[0], REAL(state), REAL(dstatedt), output);
  UNPROTECT(1);
  return dstatedt;
}

// Translate all elements in the struct back to R
// This will mostly be useful for debugging.
SEXP SLIR_deterministic_odin_contents(SEXP SLIR_deterministic_odin_ptr) {
  SLIR_deterministic_odin_pars *SLIR_deterministic_odin_p = SLIR_deterministic_odin_get_pointer(SLIR_deterministic_odin_ptr, 1);
  SEXP state = PROTECT(allocVector(VECSXP, 18));
  SET_VECTOR_ELT(state, 0, ScalarInteger(SLIR_deterministic_odin_p->odin_use_dde));
  SET_VECTOR_ELT(state, 1, ScalarReal(SLIR_deterministic_odin_p->initial_t));
  SET_VECTOR_ELT(state, 2, ScalarReal(SLIR_deterministic_odin_p->initial_L));
  SET_VECTOR_ELT(state, 3, ScalarReal(SLIR_deterministic_odin_p->beta));
  SET_VECTOR_ELT(state, 4, ScalarReal(SLIR_deterministic_odin_p->dur_lag));
  SET_VECTOR_ELT(state, 5, ScalarReal(SLIR_deterministic_odin_p->r));
  SET_VECTOR_ELT(state, 6, ScalarReal(SLIR_deterministic_odin_p->I_init));
  SET_VECTOR_ELT(state, 7, ScalarReal(SLIR_deterministic_odin_p->R_init));
  SET_VECTOR_ELT(state, 8, ScalarReal(SLIR_deterministic_odin_p->N));
  SET_VECTOR_ELT(state, 9, ScalarReal(SLIR_deterministic_odin_p->initial_S));
  SET_VECTOR_ELT(state, 10, ScalarReal(SLIR_deterministic_odin_p->initial_I));
  SET_VECTOR_ELT(state, 11, ScalarReal(SLIR_deterministic_odin_p->initial_R));
  SET_VECTOR_ELT(state, 12, ScalarInteger(SLIR_deterministic_odin_p->dim_delay_S_delay));
  SET_VECTOR_ELT(state, 13, allocVector(INTSXP, SLIR_deterministic_odin_p->dim_delay_S_delay));
  memcpy(INTEGER(VECTOR_ELT(state, 13)), SLIR_deterministic_odin_p->delay_i_S_delay, SLIR_deterministic_odin_p->dim_delay_S_delay * sizeof(int));
  SET_VECTOR_ELT(state, 14, allocVector(REALSXP, SLIR_deterministic_odin_p->dim_delay_S_delay));
  memcpy(REAL(VECTOR_ELT(state, 14)), SLIR_deterministic_odin_p->delay_state_S_delay, SLIR_deterministic_odin_p->dim_delay_S_delay * sizeof(double));
  SET_VECTOR_ELT(state, 15, ScalarInteger(SLIR_deterministic_odin_p->dim_delay_I_delay));
  SET_VECTOR_ELT(state, 16, allocVector(INTSXP, SLIR_deterministic_odin_p->dim_delay_I_delay));
  memcpy(INTEGER(VECTOR_ELT(state, 16)), SLIR_deterministic_odin_p->delay_i_I_delay, SLIR_deterministic_odin_p->dim_delay_I_delay * sizeof(int));
  SET_VECTOR_ELT(state, 17, allocVector(REALSXP, SLIR_deterministic_odin_p->dim_delay_I_delay));
  memcpy(REAL(VECTOR_ELT(state, 17)), SLIR_deterministic_odin_p->delay_state_I_delay, SLIR_deterministic_odin_p->dim_delay_I_delay * sizeof(double));
  SEXP state_names = PROTECT(allocVector(STRSXP, 18));
  SET_STRING_ELT(state_names, 0, mkChar("odin_use_dde"));
  SET_STRING_ELT(state_names, 1, mkChar("initial_t"));
  SET_STRING_ELT(state_names, 2, mkChar("initial_L"));
  SET_STRING_ELT(state_names, 3, mkChar("beta"));
  SET_STRING_ELT(state_names, 4, mkChar("dur_lag"));
  SET_STRING_ELT(state_names, 5, mkChar("r"));
  SET_STRING_ELT(state_names, 6, mkChar("I_init"));
  SET_STRING_ELT(state_names, 7, mkChar("R_init"));
  SET_STRING_ELT(state_names, 8, mkChar("N"));
  SET_STRING_ELT(state_names, 9, mkChar("initial_S"));
  SET_STRING_ELT(state_names, 10, mkChar("initial_I"));
  SET_STRING_ELT(state_names, 11, mkChar("initial_R"));
  SET_STRING_ELT(state_names, 12, mkChar("dim_delay_S_delay"));
  SET_STRING_ELT(state_names, 13, mkChar("delay_i_S_delay"));
  SET_STRING_ELT(state_names, 14, mkChar("delay_state_S_delay"));
  SET_STRING_ELT(state_names, 15, mkChar("dim_delay_I_delay"));
  SET_STRING_ELT(state_names, 16, mkChar("delay_i_I_delay"));
  SET_STRING_ELT(state_names, 17, mkChar("delay_state_I_delay"));
  setAttrib(state, R_NamesSymbol, state_names);
  UNPROTECT(2);
  return state;
}

// Report back to R information on variable ordering
// The reported information includes position and length of each
// variable, from which offset, etc, can be worked out.
SEXP SLIR_deterministic_odin_variable_order(SEXP SLIR_deterministic_odin_ptr) {
  SEXP state_len = PROTECT(allocVector(VECSXP, 4));
  SEXP state_names = PROTECT(allocVector(STRSXP, 4));
  SET_VECTOR_ELT(state_len, 0, R_NilValue);
  SET_STRING_ELT(state_names, 0, mkChar("S"));
  SET_VECTOR_ELT(state_len, 1, R_NilValue);
  SET_STRING_ELT(state_names, 1, mkChar("L"));
  SET_VECTOR_ELT(state_len, 2, R_NilValue);
  SET_STRING_ELT(state_names, 2, mkChar("I"));
  SET_VECTOR_ELT(state_len, 3, R_NilValue);
  SET_STRING_ELT(state_names, 3, mkChar("R"));
  setAttrib(state_len, R_NamesSymbol, state_names);
  UNPROTECT(2);
  return state_len;
}

SLIR_deterministic_odin_pars* SLIR_deterministic_odin_get_pointer(SEXP SLIR_deterministic_odin_ptr, int closed_error) {
  SLIR_deterministic_odin_pars *SLIR_deterministic_odin_p = NULL;
  if (TYPEOF(SLIR_deterministic_odin_ptr) != EXTPTRSXP) {
    Rf_error("Expected an external pointer");
  }
  SLIR_deterministic_odin_p = (SLIR_deterministic_odin_pars*) R_ExternalPtrAddr(SLIR_deterministic_odin_ptr);
  if (!SLIR_deterministic_odin_p && closed_error) {
    Rf_error("Pointer has been invalidated");
  }
  return SLIR_deterministic_odin_p;
}

SEXP get_ds_pars() {
  static DL_FUNC get_deSolve_gparms = NULL;
  if (get_deSolve_gparms == NULL) {
    get_deSolve_gparms = R_GetCCallable("deSolve", "get_deSolve_gparms");
  }
  return get_deSolve_gparms();
}
double get_user_double(SEXP user, const char *name, double default_value) {
  double ret = default_value;
  SEXP el = get_list_element(user, name);
  if (el != R_NilValue) {
    if (length(el) != 1) {
      Rf_error("Expected scalar numeric for %s", name);
    }
    if (TYPEOF(el) == REALSXP) {
      ret = REAL(el)[0];
    } else if (TYPEOF(el) == INTSXP) {
      ret = INTEGER(el)[0];
    } else {
      Rf_error("Expected a numeric value for %s", name);
    }
  }
  if (ISNA(ret)) {
    Rf_error("Expected value for %s", name);
  }
  return ret;
}
SEXP get_list_element(SEXP list, const char *name) {
  SEXP ret = R_NilValue, names = getAttrib(list, R_NamesSymbol);
  for (int i = 0; i < length(list); ++i) {
    if(strcmp(CHAR(STRING_ELT(names, i)), name) == 0) {
      ret = VECTOR_ELT(list, i);
      break;
    }
  }
  return ret;
}
void lagvalue_dde(double t, int *idx, size_t dim_idx, double *state) {
  typedef void (*lagvalue_type)(double, int*, size_t, double*);
  static lagvalue_type fun = NULL;
  if (fun == NULL) {
    fun = (lagvalue_type)R_GetCCallable("dde", "ylag_vec_int");
  }
  fun(t, idx, dim_idx, state);
}
void lagvalue_ds(double t, int *idx, int dim_idx, double *state) {
  typedef void (*lagvalue_type)(double, int*, int, double*);
  static lagvalue_type fun = NULL;
  if (fun == NULL) {
    fun = (lagvalue_type)R_GetCCallable("deSolve", "lagvalue");
  }
  fun(t, idx, dim_idx, state);
}
